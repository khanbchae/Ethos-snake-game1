const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const CELL = 40;
const COLS = Math.floor(canvas.width / CELL);
const ROWS = Math.floor(canvas.height / CELL);
let speed = 5;

const ethImg = new Image();
ethImg.src = "pAFgpio-_400x400.jpg";

let snake;
let apple;
let bonusApple = null;           // <-- new bonus apple variable
let normalApplesEaten = 0;       // <-- count normal apples eaten
let dir;
let nextDir;
let score = 0;
let best = parseInt(localStorage.getItem("ethSnakeBest") || "0", 10);
let lastTime = 0;
let gameOver = false;

const BONUS_BONUS_POINTS = 3;    // Bonus apple points

const scoreValueEl = document.getElementById("score-value");
const highScoreValueEl = document.getElementById("high-score-value");
highScoreValueEl.textContent = best;

const eatSound = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");

function reset() {
  snake = [
    { x: Math.floor(COLS/2), y: Math.floor(ROWS/2) },
    { x: Math.floor(COLS/2)-1, y: Math.floor(ROWS/2) },
  ];
  dir = { x: 1, y: 0 };
  nextDir = { ...dir };
  placeApple();
  bonusApple = null;
  normalApplesEaten = 0;
  score = 0;
  scoreValueEl.textContent = score;
  speed = 5;
  lastTime = performance.now();
  gameOver = false;
  window.requestAnimationFrame(gameLoop);
}

function placeApple() {
  let valid;
  do {
    apple = {
      x: Math.floor(Math.random() * COLS),
      y: Math.floor(Math.random() * ROWS)
    };
    // Ensure apple is not on snake or bonus apple
    valid = !snake.some(s => s.x === apple.x && s.y === apple.y)
            && (!bonusApple || (apple.x !== bonusApple.x || apple.y !== bonusApple.y));
  } while (!valid);
}

function placeBonusApple() {
  let valid;
  do {
    bonusApple = {
      x: Math.floor(Math.random() * COLS),
      y: Math.floor(Math.random() * ROWS)
    };
    valid = !snake.some(s => s.x === bonusApple.x && s.y === bonusApple.y)
            && (apple.x !== bonusApple.x || apple.y !== bonusApple.y);
  } while (!valid);
}

function update() {
  dir = nextDir;
  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

  if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
    endGame();
    return;
  }
  if (snake.some(s => s.x === head.x && s.y === head.y)) {
    endGame();
    return;
  }

  snake.unshift(head);

  if (head.x === apple.x && head.y === apple.y) {
    // Ate normal apple
    score++;
    normalApplesEaten++;
    eatSound.play().catch(() => {});
    updateScoreDisplay(score);
    if (speed < 15) speed += 0.3;

    // After 6 normal apples eaten, spawn bonus apple if none exists
    if (normalApplesEaten === 6 && bonusApple === null) {
      placeBonusApple();
    } else {
      placeApple();
    }
  }
  else if (bonusApple && head.x === bonusApple.x && head.y === bonusApple.y) {
    // Ate bonus apple
    score += BONUS_BONUS_POINTS;
    eatSound.play().catch(() => {});
    updateScoreDisplay(score);
    bonusApple = null;
    normalApplesEaten = 0;
    placeApple();
  }
  else {
    snake.pop();
  }
}

function endGame() {
  gameOver = true;
  setTimeout(() => {
    alert("Game Over! Score: " + score);
  }, 50);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Background fill
  ctx.fillStyle = "rgba(20,24,50,0.9)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Normal apple glow & apple
  const ax = apple.x * CELL + CELL/2;
  const ay = apple.y * CELL + CELL/2;

  const gradient = ctx.createRadialGradient(ax, ay, CELL*0.15, ax, ay, CELL*1.3);
  gradient.addColorStop(0, "rgba(255,79,79,0.9)");
  gradient.addColorStop(0.4, "rgba(255,79,79,0.3)");
  gradient.addColorStop(1, "rgba(255,79,79,0)");
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(ax, ay, CELL * 1.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#ff4f4f";
  ctx.fillRect(apple.x * CELL + 8, apple.y * CELL + 8, CELL - 16, CELL - 16);
  ctx.strokeStyle = "#fff5f5";
  ctx.lineWidth = 2;
  ctx.strokeRect(apple.x * CELL + 8, apple.y * CELL + 8, CELL - 16, CELL - 16);

  // Bonus apple (if present)
  if (bonusApple) {
    const bx = bonusApple.x * CELL + CELL/2;
    const by = bonusApple.y * CELL + CELL/2;

    // Blue glow radial gradient
    const bonusGradient = ctx.createRadialGradient(bx, by, CELL*0.15, bx, by, CELL*1.3);
    bonusGradient.addColorStop(0, "rgba(92, 99, 224, 0.9)");
    bonusGradient.addColorStop(0.4, "rgba(92, 99, 224, 0.3)");
    bonusGradient.addColorStop(1, "rgba(92, 99, 224, 0)");
    ctx.fillStyle = bonusGradient;
    ctx.beginPath();
    ctx.arc(bx, by, CELL * 1.3, 0, Math.PI * 2);
    ctx.fill();

    // Draw Ethereum logo with blue tint
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.filter = "hue-rotate(200deg) saturate(150%) brightness(110%)";
    ctx.drawImage(ethImg, bonusApple.x * CELL + 8, bonusApple.y * CELL + 8, CELL - 16, CELL - 16);
    ctx.restore();

    ctx.strokeStyle = "#ffffffcc";
    ctx.lineWidth = 2;
    ctx.strokeRect(bonusApple.x * CELL + 8, bonusApple.y * CELL + 8, CELL - 16, CELL - 16);
  }

  // Draw snake
  snake.forEach((seg, i) => {
    const px = seg.x * CELL;
    const py = seg.y * CELL;

    if (i === 0) {
      ctx.save();
      ctx.shadowColor = "rgba(142,86,255,0.7)";
      ctx.shadowBlur = 16;
      ctx.drawImage(ethImg, px, py, CELL, CELL);
      ctx.restore();
      ctx.drawImage(ethImg, px, py, CELL, CELL);
    } else {
      ctx.drawImage(ethImg, px, py, CELL, CELL);
    }
  });
}

function updateScoreDisplay(newScore) {
  scoreValueEl.textContent = newScore;
  scoreValueEl.parentElement.classList.add("score-bounce");
  setTimeout(() => scoreValueEl.parentElement.classList.remove("score-bounce"), 400);
  spawnParticles();
  if (newScore > best) {
    best = newScore;
    localStorage.setItem("ethSnakeBest", best);
    highScoreValueEl.textContent = best;
    highScoreValueEl.parentElement.classList.add("score-bounce");
    setTimeout(() => highScoreValueEl.parentElement.classList.remove("score-bounce"), 400);
  }
}

const particles = [];
function spawnParticles() {
  for (let i=0; i<12; i++) {
    particles.push({
      x: apple.x * CELL + CELL/2,
      y: apple.y * CELL + CELL/2,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      life: 30 + Math.random() * 30,
      size: 3 + Math.random() * 4,
      opacity: 1,
    });
  }
}
function updateParticles() {
  for (let i = particles.length -1; i>=0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    p.opacity = p.life / 60;
    if (p.life <= 0) particles.splice(i, 1);
  }
}
function drawParticles() {
  particles.forEach(p => {
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,79,79,${p.opacity})`;
    ctx.shadowColor = "rgba(255,79,79,0.8)";
    ctx.shadowBlur = 8;
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  });
}

function gameLoop(timestamp) {
  const delta = (timestamp - lastTime) / 1000;
  if (delta >= 1 / speed) {
    update();
    lastTime = timestamp;
  }
  draw();
  updateParticles();
  drawParticles();
  if (!gameOver) window.requestAnimationFrame(gameLoop);
}

window.addEventListener("keydown", (e) => {
  switch(e.key) {
    case "ArrowUp":
      if (dir.y !== 1) nextDir = {x:0, y:-1};
      break;
    case "ArrowDown":
      if (dir.y !== -1) nextDir = {x:0, y:1};
      break;
    case "ArrowLeft":
      if (dir.x !== 1) nextDir = {x:-1, y:0};
      break;
    case "ArrowRight":
      if (dir.x !== -1) nextDir = {x:1, y:0};
      break;
    case "r":
    case "R":
      reset();
      break;
  }
});

document.getElementById("restart").addEventListener("click", reset);

ethImg.onload = () => {
  reset();
};
